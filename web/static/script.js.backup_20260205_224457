// ============ å…¨å±€å˜é‡ ============
let currentData = null;
let selectedColor = null;
let canvas = null;
let ctx = null;
let CELL_SIZE = 12;
let editMode = false;
let cropMode = false;
let isCropping = false;
let isPainting = false;
let cropStart = null;
let cropEnd = null;
let originalImageUrl = null;
let colorCardMode = false; // è‰²å¡æ¨¡å¼ï¼šfalse=16è¿›åˆ¶æ¨¡å¼ï¼Œtrue=è‰²å¡æ¨¡å¼
let colorPickerModal = null; // è‰²å·é€‰æ‹©å™¨å¼¹çª—

// ============ åˆå§‹åŒ– ============
document.addEventListener('DOMContentLoaded', () => {
    canvas = document.getElementById('pixelCanvas');
    ctx = canvas.getContext('2d');
    
    // ç¦ç”¨æŠ—é”¯é½¿ï¼Œä¿æŒåƒç´ é£æ ¼
    ctx.imageSmoothingEnabled = false;
    
    // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
    document.getElementById('fileInput').addEventListener('change', handleFileSelect);

    // ç¼–è¾‘æ¨¡å¼æŒ‰é’®
    bindEditModeButton();
    updateEditModeUI();

    // è£å‰ªæ¨¡å¼æŒ‰é’®
    bindCropModeButton();
    updateCropModeUI();

    // SVG å¯¼å…¥å¯¼å‡ºæŒ‰é’®
    bindSvgButtons();
    
    // è‰²å¡æ¨¡å¼åˆ‡æ¢æŒ‰é’®ï¼ˆå»¶è¿Ÿç»‘å®šï¼Œç¡®ä¿æŒ‰é’®å­˜åœ¨ï¼‰
    setTimeout(() => {
        const colorCardBtn = document.getElementById('colorCardModeBtn');
        if (colorCardBtn && !colorCardBtn.onclick) {
            colorCardBtn.onclick = (event) => {
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                toggleColorCardMode();
            };
        }
    }, 0);
    
    // åŸå›¾æµ®çª—æ§åˆ¶
    bindModalControls();
    
    // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
    canvas.addEventListener('click', handleCanvasClick);
    // æ‹–æ‹½æ¶‚è‰²äº‹ä»¶
    canvas.addEventListener('mousedown', handlePaintMouseDown);
    canvas.addEventListener('mousemove', handlePaintMouseMove);
    canvas.addEventListener('mouseup', handlePaintMouseUp);
    canvas.addEventListener('mouseleave', handlePaintMouseLeave);
    // è£å‰ªæ‹–æ‹½äº‹ä»¶
    canvas.addEventListener('mousedown', handleCropMouseDown);
    canvas.addEventListener('mousemove', handleCropMouseMove);
    canvas.addEventListener('mouseup', handleCropMouseUp);
    canvas.addEventListener('mouseleave', handleCropMouseLeave);
    
    // ============ Tab åˆ‡æ¢åŠŸèƒ½ ============
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const targetTab = btn.dataset.tab;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            tabContents.forEach(content => {
                if (content.dataset.tab === targetTab) {
                    content.classList.add('active');
                    content.style.display = 'block';
                } else {
                    content.classList.remove('active');
                    content.style.display = 'none';
                }
            });
            
            // å¦‚æœåˆ‡æ¢åˆ°åº“å­˜é¡µé¢ï¼ŒåŠ è½½åº“å­˜
            if (targetTab === 'inventory') {
                loadInventoryPage();
            }
        });
    });
    
});

// ============ åŠ¨æ€è®¡ç®—æ ¼å­å¤§å° ============
function calculateOptimalCellSize(rows, cols) {
    const canvasContainer = document.querySelector('.canvas-wrapper');
    if (!canvasContainer) return 12;
    
    const maxWidth = canvasContainer.clientWidth - 40;
    const maxHeight = window.innerHeight * 0.6;
    
    const cellSizeByWidth = Math.floor(maxWidth / cols);
    const cellSizeByHeight = Math.floor(maxHeight / rows);
    
    const optimalSize = Math.min(cellSizeByWidth, cellSizeByHeight);
    return Math.max(8, Math.min(optimalSize, 20));
}

// ============ æ–‡ä»¶é€‰æ‹©å¤„ç† ============
async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // ä¿å­˜åŸå›¾ URL
    originalImageUrl = URL.createObjectURL(file);
    
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    document.getElementById('uploadSection').style.display = 'none';
    document.getElementById('loading').style.display = 'flex';
    document.getElementById('resultSection').style.display = 'none';
    
    // ä¸Šä¼ æ–‡ä»¶
    const formData = new FormData();
    formData.append('file', file);
    
    // æ·»åŠ ç”¨æˆ·é€‰ä¸­çš„è‰²å·åˆ—è¡¨
    const selectedColors = getSelectedColors();
    formData.append('selected_colors', JSON.stringify(selectedColors));
    
    try {
        console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶:', file.name);
        const response = await fetch('/upload', {
            method: 'POST',
            body: formData
        });
        
        console.log('æ”¶åˆ°å“åº”ï¼ŒçŠ¶æ€:', response.status);
        const data = await response.json();
        console.log('è§£ææ•°æ®:', data);
        
        if (data.success) {
            currentData = data;
            displayResult(data);
        } else {
            alert('âŒ å¤„ç†å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
            resetUpload();
        }
    } catch (error) {
        console.error('ä¸Šä¼ é”™è¯¯:', error);
        alert('âŒ ä¸Šä¼ å¤±è´¥: ' + error.message);
        resetUpload();
    }
}

// ============ æ˜¾ç¤ºè¯†åˆ«ç»“æœ ============
function displayResult(data) {
    // éšè—åŠ è½½ï¼Œæ˜¾ç¤ºç»“æœ
    document.getElementById('loading').style.display = 'none';
    document.getElementById('resultSection').style.display = 'block';
    
    console.log('ğŸ“¦ æ¥æ”¶åˆ°çš„æ•°æ®:', data);
    console.log('ğŸ“¦ colorCodes æ ·ä¾‹:', data.colorCodes ? data.colorCodes[0]?.[0] : 'undefined');
    
    // æ›´æ–°ä¿¡æ¯æ 
    document.getElementById('gridSize').textContent = `${data.rows} Ã— ${data.cols}`;
    // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºä¸åŒçš„é¢œè‰²ç»Ÿè®¡
    if (colorCardMode && data.palette) {
        document.getElementById('colorCount').textContent = `${Object.keys(data.palette).length} codes`;
    } else {
        document.getElementById('colorCount').textContent = `${data.totalColors} colors`;
    }
    
    // é‡ç½®é€‰æ‹©
    clearSelection();
    editMode = false;
    updateEditModeUI();
    cropMode = false;
    updateCropModeUI();
    
    // é‡æ–°ç»‘å®šç¼–è¾‘/è£å‰ª/SVGæŒ‰é’®ï¼ˆé˜²æ­¢åŠ¨æ€æ¸²æŸ“å¯¼è‡´äº‹ä»¶ä¸¢å¤±ï¼‰
    bindEditModeButton();
    bindCropModeButton();
    bindSvgButtons();
    bindModalControls();
    
    // è‰²å¡æ¨¡å¼æŒ‰é’®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const colorCardBtn = document.getElementById('colorCardModeBtn');
    if (colorCardBtn && !colorCardBtn.onclick) {
        colorCardBtn.onclick = (event) => {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            toggleColorCardMode();
        };
    }
    
    // æ˜¾ç¤ºåŸå›¾æŒ‰é’®
    if (originalImageUrl) {
        const showBtn = document.getElementById('showOriginalBtn');
        if (showBtn) {
            showBtn.style.display = 'block';
        }
    }
    
    // æ›´æ–° currentDataï¼Œç¡®ä¿åç»­æ“ä½œä½¿ç”¨æ­£ç¡®çš„é¢œè‰²æ•°æ®
    if (!data.colors) {
        console.error('é”™è¯¯ï¼šæ²¡æœ‰é¢œè‰²æ•°æ®', data);
        alert('å¤„ç†å¤±è´¥ï¼šæœåŠ¡å™¨è¿”å›çš„æ•°æ®ä¸å®Œæ•´');
        resetUpload();
        return;
    }
    
    // ç»˜åˆ¶ç”»å¸ƒï¼ˆç›´æ¥ä¼ å…¥ dataï¼Œè®© drawCanvas æ ¹æ®æ¨¡å¼åˆ¤æ–­ï¼‰
    drawCanvas(data);
    
    // æ˜¾ç¤ºè‰²å·ç»Ÿè®¡
    displayColorStats(data);
    
    // å¹³æ»‘æ»šåŠ¨åˆ°ç”»å¸ƒåŒºåŸŸ
    setTimeout(() => {
        document.querySelector('.canvas-panel').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 100);
}

// ============ ç»˜åˆ¶ç”»å¸ƒ ============
function drawCanvas(data) {
    const { rows, cols } = data;
    
    // æ ¹æ®æ¨¡å¼é€‰æ‹©é¢œè‰²æ•°æ®
    const colors = (colorCardMode && data.mappedColors) ? data.mappedColors : data.colors;
    
    // åŠ¨æ€è®¡ç®—æ ¼å­å¤§å°
    CELL_SIZE = calculateOptimalCellSize(rows, cols);
    
    // è®¾ç½®ç”»å¸ƒå¤§å°
    canvas.width = cols * CELL_SIZE;
    canvas.height = rows * CELL_SIZE;
    
    // ç»˜åˆ¶æ¯ä¸ªæ ¼å­
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            const color = colors[i][j];
            drawCell(i, j, color, false);
        }
    }
    
    // ç»˜åˆ¶ç½‘æ ¼çº¿
    drawGrid(rows, cols);
}

// ============ ç»˜åˆ¶å•ä¸ªæ ¼å­ ============
function drawCell(row, col, color, isDimmed = false) {
    const x = col * CELL_SIZE;
    const y = row * CELL_SIZE;
    
    // å¡«å……é¢œè‰² - ç¡®ä¿æ˜¯æœ‰æ•ˆçš„hexæ ¼å¼
    ctx.fillStyle = color;
    ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
    
    // å¦‚æœæ˜¯æš—åŒ–çŠ¶æ€
    if (isDimmed) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
    }
    
    // é«˜äº®è¾¹æ¡†
    if (selectedColor && color === selectedColor) {
        ctx.strokeStyle = 'rgba(255, 107, 53, 0.9)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 0.5, y + 0.5, CELL_SIZE - 1, CELL_SIZE - 1);
    }
}

// ============ ç»˜åˆ¶ç½‘æ ¼çº¿ ============
function drawGrid(rows, cols) {
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.lineWidth = 0.5;
    
    // å‚ç›´çº¿
    for (let i = 0; i <= cols; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, rows * CELL_SIZE);
        ctx.stroke();
    }
    
    // æ°´å¹³çº¿
    for (let i = 0; i <= rows; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(cols * CELL_SIZE, i * CELL_SIZE);
        ctx.stroke();
    }
}

// ============ ç”»å¸ƒç‚¹å‡»å¤„ç† ============
async function handleCanvasClick(event) {
    if (!currentData) return;
    if (cropMode) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const col = Math.floor(x / CELL_SIZE);
    const row = Math.floor(y / CELL_SIZE);
    
    if (row >= 0 && row < currentData.rows && col >= 0 && col < currentData.cols) {
        const clickedColor = currentData.colors[row][col];
        
        // è‰²å¡æ¨¡å¼ä¸”æœ‰ Top 3 æ•°æ®ï¼šæ˜¾ç¤ºé€‰æ‹©å™¨
        if (colorCardMode && currentData.colorCodes && currentData.colorCodes[row] && currentData.colorCodes[row][col]) {
            const cellData = currentData.colorCodes[row][col];
            if (cellData.top_3) {
                showColorPicker(row, col, cellData.top_3, event);
                return;
            }
        }
        
        // æ™®é€šæ¨¡å¼æˆ–ç¼–è¾‘æ¨¡å¼
        if (editMode && selectedColor) {
            await applyColorToCell(row, col, selectedColor);
        } else {
            // æ ¹æ®æ¨¡å¼é€‰æ‹©æ­£ç¡®çš„é¢œè‰²
            const colorToSelect = colorCardMode && currentData.mappedColors 
                ? currentData.mappedColors[row][col] 
                : clickedColor;
            selectColor(colorToSelect);
        }
    }
}

async function handlePaintMouseDown(event) {
    if (!currentData || cropMode || !editMode || !selectedColor) return;
    const { row, col } = getCellFromEvent(event);
    if (row === null || col === null) return;
    isPainting = true;
    await applyColorToCell(row, col, selectedColor);
}

async function handlePaintMouseMove(event) {
    if (!isPainting || !currentData || cropMode || !editMode || !selectedColor) return;
    const { row, col } = getCellFromEvent(event);
    if (row === null || col === null) return;
    await applyColorToCell(row, col, selectedColor);
}

function handlePaintMouseUp() {
    isPainting = false;
}

function handlePaintMouseLeave() {
    isPainting = false;
}

// ============ ç¼–è¾‘æ¨¡å¼åˆ‡æ¢ ============
function toggleEditMode() {
    editMode = !editMode;
    if (editMode) {
        cropMode = false;
        updateCropModeUI();
    }
    updateEditModeUI();
}

window.toggleEditMode = toggleEditMode;

function bindEditModeButton() {
    const editBtn = document.getElementById('editModeBtn');
    if (!editBtn) return;
    editBtn.onclick = (event) => {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        toggleEditMode();
    };
}

// ============ è£å‰ªæ¨¡å¼åˆ‡æ¢ ============
function toggleCropMode() {
    cropMode = !cropMode;
    if (cropMode) {
        editMode = false;
        updateEditModeUI();
    }
    resetCropSelection();
    updateCropModeUI();
}

window.toggleCropMode = toggleCropMode;

function bindCropModeButton() {
    const cropBtn = document.getElementById('cropModeBtn');
    if (!cropBtn) return;
    cropBtn.onclick = (event) => {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        toggleCropMode();
    };
}

// ============ è‰²å¡æ¨¡å¼åˆ‡æ¢ ============
function toggleColorCardMode() {
    if (!currentData) return;
    
    colorCardMode = !colorCardMode;
    updateColorCardModeUI();
    
    // é‡æ–°æ¸²æŸ“ç”»å¸ƒå’Œè°ƒè‰²æ¿ï¼ˆç›´æ¥ä¼ å…¥ currentDataï¼Œè®© drawCanvas è‡ªå·±åˆ¤æ–­ï¼‰
    drawCanvas(currentData);
    displayColorStats(currentData);
    
    // æ›´æ–°é¢œè‰²ç»Ÿè®¡æ ‡é¢˜
    if (colorCardMode && currentData.palette) {
        document.getElementById('colorCount').textContent = `${Object.keys(currentData.palette).length} codes`;
    } else {
        document.getElementById('colorCount').textContent = `${currentData.totalColors} colors`;
    }
}

function updateColorCardModeUI() {
    const colorCardBtn = document.getElementById('colorCardModeBtn');
    if (!colorCardBtn) return;
    
    if (colorCardMode) {
        colorCardBtn.classList.add('active');
        colorCardBtn.textContent = 'Color Card';
    } else {
        colorCardBtn.classList.remove('active');
        colorCardBtn.textContent = 'HEX Mode';
    }
}

// ============ SVG å¯¼å…¥å¯¼å‡º ==========
function bindSvgButtons() {
    const saveBtn = document.getElementById('saveSvgBtn');
    const importBtn = document.getElementById('importSvgBtn');
    const svgInput = document.getElementById('svgInput');

    if (saveBtn) {
        saveBtn.onclick = (event) => {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            handleSaveSvg();
        };
    }

    if (importBtn && svgInput) {
        importBtn.onclick = (event) => {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            svgInput.click();
        };
    }

    if (svgInput) {
        svgInput.onchange = handleImportSvgChange;
    }
}

async function handleSaveSvg() {
    if (!currentData) return;

    try {
        const response = await fetch('/export_svg', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                rows: currentData.rows,
                cols: currentData.cols,
                colors: currentData.colors,
                cellSize: CELL_SIZE
            })
        });

        if (!response.ok) {
            throw new Error('å¯¼å‡ºå¤±è´¥');
        }

        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `pixelart_${currentData.rows}x${currentData.cols}.svg`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
    } catch (error) {
        alert('âŒ å¯¼å‡ºå¤±è´¥: ' + error.message);
    }
}

async function handleImportSvgChange(event) {
    const file = event.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);

    try {
        const response = await fetch('/import_svg', {
            method: 'POST',
            body: formData
        });

        const data = await response.json();

        if (data.success) {
            currentData = data;
            displayResult(data);
        } else {
            alert('âŒ å¯¼å…¥å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        alert('âŒ å¯¼å…¥å¤±è´¥: ' + error.message);
    } finally {
        event.target.value = '';
    }
}

function updateCropModeUI() {
    const cropBtn = document.getElementById('cropModeBtn');
    const hint = document.getElementById('cropHint');
    if (cropBtn) {
        cropBtn.textContent = 'Crop Mode';
        cropBtn.classList.toggle('active', cropMode);
    }
    if (hint) {
        hint.style.display = cropMode ? 'block' : 'none';
    }
}

function resetCropSelection() {
    isCropping = false;
    cropStart = null;
    cropEnd = null;
    if (currentData) {
        redrawWithHighlight();
    }
}

// ============ åŸå›¾æµ®çª—æ§åˆ¶ ============
function bindModalControls() {
    const showBtn = document.getElementById('showOriginalBtn');
    const modal = document.getElementById('originalModal');
    const closeBtn = document.getElementById('closeModal');
    const modalHeader = document.querySelector('.modal-header');
    const modalImg = document.getElementById('originalImgModal');
    
    if (showBtn) {
        showBtn.onclick = () => {
            if (modal && originalImageUrl) {
                if (modalImg) modalImg.src = originalImageUrl;
                modal.style.display = 'flex';
            }
        };
    }
    
    if (closeBtn && modal) {
        closeBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }
    
    // æ‹–åŠ¨åŠŸèƒ½
    if (modalHeader && modal) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        
        modalHeader.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            isDragging = true;
            initialX = e.clientX - modal.offsetLeft;
            initialY = e.clientY - modal.offsetTop;
            modal.style.transform = 'none';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            modal.style.left = currentX + 'px';
            modal.style.top = currentY + 'px';
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }
}

function handleCropMouseDown(event) {
    if (!cropMode || !currentData) return;
    const { row, col } = getCellFromEvent(event);
    if (row === null || col === null) return;
    isCropping = true;
    cropStart = { row, col };
    cropEnd = { row, col };
    redrawWithCropOverlay();
}

function handleCropMouseMove(event) {
    if (!cropMode || !isCropping || !currentData) return;
    const { row, col } = getCellFromEvent(event);
    if (row === null || col === null) return;
    cropEnd = { row, col };
    redrawWithCropOverlay();
}

function handleCropMouseUp() {
    if (!cropMode || !isCropping || !currentData) return;
    isCropping = false;
    applyCropSelection();
}

function handleCropMouseLeave() {
    if (!cropMode || !isCropping) return;
    isCropping = false;
    redrawWithCropOverlay();
}

function getCellFromEvent(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const col = Math.floor(x / CELL_SIZE);
    const row = Math.floor(y / CELL_SIZE);
    if (!currentData || row < 0 || col < 0 || row >= currentData.rows || col >= currentData.cols) {
        return { row: null, col: null };
    }
    return { row, col };
}

function redrawWithCropOverlay() {
    redrawWithHighlight();
    if (!cropStart || !cropEnd) return;
    const minRow = Math.min(cropStart.row, cropEnd.row);
    const maxRow = Math.max(cropStart.row, cropEnd.row);
    const minCol = Math.min(cropStart.col, cropEnd.col);
    const maxCol = Math.max(cropStart.col, cropEnd.col);

    const x = minCol * CELL_SIZE;
    const y = minRow * CELL_SIZE;
    const w = (maxCol - minCol + 1) * CELL_SIZE;
    const h = (maxRow - minRow + 1) * CELL_SIZE;

    ctx.save();
    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
    ctx.strokeStyle = 'rgba(255, 165, 0, 0.9)';
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
    ctx.restore();
}

function applyCropSelection() {
    if (!cropStart || !cropEnd) return;
    const minRow = Math.min(cropStart.row, cropEnd.row);
    const maxRow = Math.max(cropStart.row, cropEnd.row);
    const minCol = Math.min(cropStart.col, cropEnd.col);
    const maxCol = Math.max(cropStart.col, cropEnd.col);

    // è£å‰ªåŸå§‹é¢œè‰²æ•°ç»„
    const newColors = [];
    for (let r = minRow; r <= maxRow; r++) {
        const newRow = currentData.colors[r].slice(minCol, maxCol + 1);
        newColors.push(newRow);
    }

    // åŒæ­¥è£å‰ªæ˜ å°„é¢œè‰²æ•°ç»„
    if (currentData.mappedColors) {
        const newMappedColors = [];
        for (let r = minRow; r <= maxRow; r++) {
            const newRow = currentData.mappedColors[r].slice(minCol, maxCol + 1);
            newMappedColors.push(newRow);
        }
        currentData.mappedColors = newMappedColors;
    }

    // åŒæ­¥è£å‰ªè‰²å·æ•°æ®
    if (currentData.colorCodes) {
        const newColorCodes = [];
        for (let r = minRow; r <= maxRow; r++) {
            const newRow = currentData.colorCodes[r].slice(minCol, maxCol + 1);
            newColorCodes.push(newRow);
        }
        currentData.colorCodes = newColorCodes;
    }

    currentData.colors = newColors;
    currentData.rows = newColors.length;
    currentData.cols = newColors[0]?.length || 0;

    // é‡æ–°æ„å»ºç»Ÿè®¡æ•°æ®
    rebuildColorStatsFromGrid();
    if (currentData.colorCodes) {
        rebuildPaletteFromColorCodes();
    }
    
    resetCropSelection();
    drawCanvas(currentData);
    displayColorStats(currentData);
    document.getElementById('gridSize').textContent = `${currentData.rows} Ã— ${currentData.cols}`;
}

function rebuildColorStatsFromGrid() {
    const stats = {};
    for (let r = 0; r < currentData.colors.length; r++) {
        for (let c = 0; c < currentData.colors[r].length; c++) {
            const color = currentData.colors[r][c];
            if (stats[color]) {
                stats[color].count += 1;
            } else {
                stats[color] = {
                    rgb: hexToRgbString(color),
                    count: 1
                };
            }
        }
    }
    currentData.colorStats = stats;
    currentData.totalColors = Object.keys(stats).length;
}

async function applyColorToCell(row, col, newColor) {
    const oldColor = currentData.colors[row][col];
    
    // æ›´æ–°åŸå§‹é¢œè‰²æ•°ç»„
    currentData.colors[row][col] = newColor;
    
    // å¦‚æœæœ‰è‰²å·æ•°æ®ï¼Œéœ€è¦é‡æ–°æ˜ å°„è¿™ä¸ªåƒç´ åˆ°æœ€æ¥è¿‘çš„è‰²å·
    if (currentData.mappedColors && currentData.colorCodes) {
        // è°ƒç”¨åç«¯APIé‡æ–°æ˜ å°„é¢œè‰²ï¼ˆç­‰å¾…å®Œæˆï¼‰
        await remapSingleColor(row, col, newColor);
    }
    
    updateColorStatsData(oldColor, newColor);
    redrawWithHighlight();
}

// é‡æ–°æ˜ å°„å•ä¸ªé¢œè‰²åˆ°æœ€æ¥è¿‘çš„è‰²å·
async function remapSingleColor(row, col, hexColor) {
    try {
        const rgb = hexToRgb(hexColor);
        const selectedColors = getSelectedColors();
        
        const response = await fetch('/api/find_color', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                rgb: rgb,
                selected_colors: selectedColors
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // æ›´æ–°æ˜ å°„é¢œè‰²
            currentData.mappedColors[row][col] = data.mapped_hex;
            
            // æ›´æ–° colorCodes
            currentData.colorCodes[row][col] = {
                original: rgb,
                code: data.code,
                mapped: data.mapped_rgb,
                delta_e: data.delta_e,
                top_3: data.top_3
            };
            
            // é‡å»ºè‰²å·ç»Ÿè®¡
            rebuildPaletteFromColorCodes();
            
            // å¦‚æœå½“å‰åœ¨è‰²å¡æ¨¡å¼ï¼Œé‡æ–°ç»˜åˆ¶
            if (colorCardMode) {
                drawCanvas(currentData);
            }
        }
    } catch (error) {
        console.error('é‡æ–°æ˜ å°„é¢œè‰²å¤±è´¥:', error);
    }
}

// è¾…åŠ©å‡½æ•°ï¼šhex è½¬ rgb æ•°ç»„
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ] : [0, 0, 0];
}

function updateColorStatsData(oldColor, newColor) {
    const stats = {};
    for (let r = 0; r < currentData.colors.length; r++) {
        for (let c = 0; c < currentData.colors[r].length; c++) {
            const color = currentData.colors[r][c];
            if (stats[color]) {
                stats[color].count += 1;
            } else {
                stats[color] = {
                    rgb: hexToRgbString(color),
                    count: 1
                };
            }
        }
    }
    currentData.colorStats = stats;
    currentData.totalColors = Object.keys(stats).length;
}

function updateEditModeUI() {
    const editBtn = document.getElementById('editModeBtn');
    if (!editBtn) return;
    editBtn.textContent = 'Edit Mode';
    editBtn.classList.toggle('active', editMode);
}

function updateColorStatsData(oldColor, newColor) {
    const stats = currentData.colorStats || {};

    if (stats[oldColor]) {
        stats[oldColor].count -= 1;
        if (stats[oldColor].count <= 0) {
            delete stats[oldColor];
        }
    }

    if (stats[newColor]) {
        stats[newColor].count += 1;
    } else {
        stats[newColor] = {
            rgb: hexToRgbString(newColor),
            count: 1
        };
    }

    currentData.colorStats = stats;
    currentData.totalColors = Object.keys(stats).length;
    document.getElementById('colorCount').textContent = `${currentData.totalColors}`;

    displayColorStats(currentData);
    updateColorStatsSelection(selectedColor);
}

function hexToRgbString(hex) {
    const cleaned = hex.replace('#', '');
    const r = parseInt(cleaned.substring(0, 2), 16);
    const g = parseInt(cleaned.substring(2, 4), 16);
    const b = parseInt(cleaned.substring(4, 6), 16);
    return `RGB(${r},${g},${b})`;
}

// ============ é¢œè‰²é€‰æ‹© ============
function selectColor(color) {
    if (selectedColor === color) {
        // å–æ¶ˆé€‰æ‹©
        clearSelection();
        return;
    }
    
    selectedColor = color;
    
    // é‡æ–°ç»˜åˆ¶ç”»å¸ƒï¼ˆé«˜äº®é€‰ä¸­é¢œè‰²ï¼‰
    redrawWithHighlight();
    
    // æ›´æ–°å·¥å…·æ æ˜¾ç¤º
    updateToolbarSelection(color);
    
    // æ›´æ–°è‰²å·ç»Ÿè®¡çš„é€‰ä¸­çŠ¶æ€
    updateColorStatsSelection(color);
}

// ============ é‡æ–°ç»˜åˆ¶ç”»å¸ƒï¼ˆå¸¦é«˜äº®ï¼‰============
function redrawWithHighlight() {
    if (!currentData) return;
    
    const { rows, cols } = currentData;
    // æ ¹æ®æ¨¡å¼é€‰æ‹©é¢œè‰²æ•°æ®
    const colors = (colorCardMode && currentData.mappedColors) ? currentData.mappedColors : currentData.colors;
    
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            const color = colors[i][j];
            const isDimmed = selectedColor && color !== selectedColor;
            drawCell(i, j, color, isDimmed);
        }
    }
    
    drawGrid(rows, cols);
}

// ============ æ›´æ–°å·¥å…·æ é€‰ä¸­çŠ¶æ€ ============
function updateToolbarSelection(color) {
    const badge = document.getElementById('selectedColorBadge');
    const colorDot = document.getElementById('colorDot');
    const colorText = document.getElementById('selectedColorText');
    
    if (color) {
        colorDot.style.backgroundColor = color;
        colorText.textContent = color.toUpperCase();
        badge.style.display = 'inline-flex';
    } else {
        badge.style.display = 'none';
    }
}

// ============ Top 3 è‰²å·é€‰æ‹©å™¨ ============
function showColorPicker(row, col, top3Options, event) {
    // ç§»é™¤å·²å­˜åœ¨çš„é€‰æ‹©å™¨
    closeColorPicker();
    
    // åˆ›å»ºé€‰æ‹©å™¨å®¹å™¨
    const picker = document.createElement('div');
    picker.id = 'colorPickerModal';
    picker.style.cssText = `
        position: fixed;
        background: white;
        border: 4px solid #333;
        box-shadow: 8px 8px 0 rgba(0,0,0,0.3);
        padding: 15px;
        z-index: 10000;
        min-width: 200px;
    `;
    
    // æ ‡é¢˜
    const title = document.createElement('div');
    title.textContent = 'Select Color Code';
    title.style.cssText = `
        font-weight: bold;
        font-size: 12px;
        margin-bottom: 10px;
        font-family: "Courier New", monospace;
        text-align: center;
        color: #d32f2f;
    `;
    picker.appendChild(title);
    
    // Top 3 é€‰é¡¹
    top3Options.forEach((option, index) => {
        const item = document.createElement('div');
        item.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin: 5px 0;
            cursor: pointer;
            border: 2px solid #ddd;
            background: ${index === 0 ? '#f9f9f9' : 'white'};
            transition: all 0.1s;
        `;
        
        // è‰²å—
        const swatch = document.createElement('div');
        swatch.style.cssText = `
            width: 30px;
            height: 30px;
            background-color: ${option.hex};
            border: 2px solid #333;
            flex-shrink: 0;
        `;
        
        // ä¿¡æ¯
        const info = document.createElement('div');
        info.style.cssText = `
            flex: 1;
            font-family: "Courier New", monospace;
        `;
        
        const code = document.createElement('div');
        code.textContent = option.code;
        code.style.cssText = `
            font-weight: bold;
            font-size: 14px;
        `;
        
        const deltaE = document.createElement('div');
        deltaE.textContent = `Î”E: ${option.delta_e}`;
        deltaE.style.cssText = `
            font-size: 10px;
            color: #666;
        `;
        
        info.appendChild(code);
        info.appendChild(deltaE);
        
        // å½“å‰é€‰ä¸­æ ‡è®°
        if (index === 0) {
            const badge = document.createElement('span');
            badge.textContent = 'âœ“';
            badge.style.cssText = `
                color: #4caf50;
                font-weight: bold;
                font-size: 18px;
            `;
            item.appendChild(badge);
        }
        
        item.appendChild(swatch);
        item.appendChild(info);
        
        // æ‚¬åœæ•ˆæœ
        item.addEventListener('mouseenter', () => {
            item.style.transform = 'translateX(4px)';
            item.style.borderColor = '#333';
        });
        
        item.addEventListener('mouseleave', () => {
            item.style.transform = 'translateX(0)';
            item.style.borderColor = '#ddd';
        });
        
        // ç‚¹å‡»é€‰æ‹©
        item.addEventListener('click', () => {
            applyColorCodeToCell(row, col, option);
            closeColorPicker();
        });
        
        picker.appendChild(item);
    });
    
    // å–æ¶ˆæŒ‰é’®
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = `
        width: 100%;
        margin-top: 10px;
        padding: 8px;
        border: 2px solid #333;
        background: white;
        cursor: pointer;
        font-family: "Courier New", monospace;
        font-weight: bold;
        font-size: 12px;
    `;
    
    cancelBtn.addEventListener('click', closeColorPicker);
    cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = '#f0f0f0';
    });
    cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = 'white';
    });
    
    picker.appendChild(cancelBtn);
    
    // å®šä½ï¼ˆé¼ æ ‡æ—è¾¹ï¼‰
    document.body.appendChild(picker);
    
    const x = Math.min(event.clientX + 10, window.innerWidth - picker.offsetWidth - 20);
    const y = Math.min(event.clientY + 10, window.innerHeight - picker.offsetHeight - 20);
    
    picker.style.left = x + 'px';
    picker.style.top = y + 'px';
    
    colorPickerModal = picker;
    
    // ç‚¹å‡»å¤–éƒ¨å…³é—­
    setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
    }, 100);
}

function closeColorPicker() {
    if (colorPickerModal) {
        colorPickerModal.remove();
        colorPickerModal = null;
        document.removeEventListener('click', handleOutsideClick);
    }
}

function handleOutsideClick(e) {
    if (colorPickerModal && !colorPickerModal.contains(e.target)) {
        closeColorPicker();
    }
}

function applyColorCodeToCell(row, col, option) {
    if (!currentData || !currentData.colorCodes) return;
    
    // è·å–å½“å‰å•å…ƒæ ¼çš„æ—§è‰²å·
    const oldCode = currentData.colorCodes[row][col].code;
    const newCode = option.code;
    
    console.log(`ğŸ”„ æ‰¹é‡æ›¿æ¢è‰²å·: ${oldCode} â†’ ${newCode}`);
    
    let replacedCount = 0;
    
    // éå†æ‰€æœ‰å•å…ƒæ ¼ï¼Œæ›¿æ¢æ‰€æœ‰ç›¸åŒè‰²å·çš„åƒç´ 
    for (let i = 0; i < currentData.rows; i++) {
        for (let j = 0; j < currentData.cols; j++) {
            const cellData = currentData.colorCodes[i][j];
            
            // å¦‚æœè‰²å·åŒ¹é…ï¼Œåˆ™æ›¿æ¢
            if (cellData.code === oldCode) {
                // æ›´æ–° colorCodes æ•°æ®
                currentData.colorCodes[i][j].code = newCode;
                currentData.colorCodes[i][j].mapped = option.rgb;
                currentData.colorCodes[i][j].delta_e = option.delta_e;
                
                // æ›´æ–° mappedColors
                currentData.mappedColors[i][j] = option.hex;
                
                replacedCount++;
            }
        }
    }
    
    console.log(`âœ… å…±æ›¿æ¢äº† ${replacedCount} ä¸ªåƒç´ `);
    
    // é‡æ–°æ„å»ºè°ƒè‰²æ¿ç»Ÿè®¡
    rebuildPaletteFromColorCodes();
    
    // åªåœ¨è‰²å¡æ¨¡å¼ä¸‹é‡ç»˜
    if (colorCardMode) {
        // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ä¸€æ¬¡æ€§å®Œæˆç»˜åˆ¶ï¼Œé¿å…é—ªçƒ
        requestAnimationFrame(() => {
            drawCanvas(currentData);
            displayColorStats(currentData);
        });
    }
}

function rebuildPaletteFromColorCodes() {
    if (!currentData || !currentData.colorCodes) return;
    
    const palette = {};
    
    // éå†æ‰€æœ‰å•å…ƒæ ¼ï¼Œç»Ÿè®¡è‰²å·ä½¿ç”¨æƒ…å†µ
    for (let i = 0; i < currentData.rows; i++) {
        for (let j = 0; j < currentData.cols; j++) {
            const cellData = currentData.colorCodes[i][j];
            const code = cellData.code;
            const rgb = cellData.mapped;
            const hex = '#{:02x}{:02x}{:02x}'.replace('{:02x}', rgb[0].toString(16).padStart(2, '0'))
                .replace('{:02x}', rgb[1].toString(16).padStart(2, '0'))
                .replace('{:02x}', rgb[2].toString(16).padStart(2, '0'));
            
            if (!palette[code]) {
                palette[code] = {
                    rgb: rgb,
                    hex: `#${rgb[0].toString(16).padStart(2, '0')}${rgb[1].toString(16).padStart(2, '0')}${rgb[2].toString(16).padStart(2, '0')}`,
                    count: 0
                };
            }
            palette[code].count++;
        }
    }
    
    // æ›´æ–° currentData
    currentData.palette = palette;
    
    console.log(`ğŸ“Š é‡å»ºè°ƒè‰²æ¿: ${Object.keys(palette).length} ç§è‰²å·`);
}

// ============ æ¸…é™¤é€‰æ‹© ============
function clearSelection() {
    selectedColor = null;
    
    if (currentData) {
        drawCanvas(currentData);
    }
    
    updateToolbarSelection(null);
    updateColorStatsSelection(null);
}

// ============ æ˜¾ç¤ºè‰²å·ç»Ÿè®¡ ============
function displayColorStats(data) {
    const container = document.getElementById('colorStatsList');
    container.innerHTML = '';
    
    console.log('ğŸ“Š displayColorStats called, colorCardMode:', colorCardMode);
    console.log('ğŸ“Š Container:', container);
    console.log('ğŸ“Š Data:', data);
    
    // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºä¸åŒå†…å®¹
    if (colorCardMode && data.palette) {
        // è‰²å¡æ¨¡å¼ï¼šæ˜¾ç¤ºæ‹¼è±†è‰²å·
        displayColorCardStats(data, container);
    } else {
        // 16è¿›åˆ¶æ¨¡å¼ï¼šæ˜¾ç¤ºåŸå§‹é¢œè‰²ç»Ÿè®¡
        displayHexColorStats(data, container);
    }
    
    console.log('ğŸ“Š Total items added:', container.children.length);
    console.log('ğŸ“Š Container scrollHeight:', container.scrollHeight, 'clientHeight:', container.clientHeight);
}

// æ˜¾ç¤º16è¿›åˆ¶é¢œè‰²ç»Ÿè®¡
function displayHexColorStats(data, container) {
    // æŒ‰æ•°é‡æ’åº
    const sortedColors = Object.entries(data.colorStats).sort((a, b) => {
        return b[1].count - a[1].count;
    });
    
    sortedColors.forEach(([hexColor, info]) => {
        const item = document.createElement('div');
        item.className = 'color-item';
        item.dataset.color = hexColor;
        
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = hexColor;
        
        const info_div = document.createElement('div');
        info_div.className = 'color-info';
        
        const hex = document.createElement('div');
        hex.className = 'color-hex';
        hex.textContent = hexColor.toUpperCase();
        hex.style.fontSize = '14px';
        hex.style.fontWeight = 'bold';
        hex.style.fontFamily = '"Courier New", monospace';
        
        const count = document.createElement('div');
        count.className = 'color-count';
        count.textContent = `Ã— ${info.count}`;
        count.style.fontSize = '10px';
        count.style.fontFamily = '"Courier New", monospace';
        count.style.fontWeight = 'bold';
        
        info_div.appendChild(hex);
        info_div.appendChild(count);
        
        item.appendChild(swatch);
        item.appendChild(info_div);
        
        // ç‚¹å‡»é€‰æ‹©
        item.addEventListener('click', () => {
            selectColor(hexColor);
        });
        
        // æ‚¬åœæ•ˆæœ
        item.addEventListener('mouseenter', () => {
            item.style.transform = 'translateX(4px)';
        });
        
        item.addEventListener('mouseleave', () => {
            item.style.transform = 'translateX(0)';
        });
        
        container.appendChild(item);
    });
}

// æ˜¾ç¤ºè‰²å¡ç»Ÿè®¡
function displayColorCardStats(data, container) {
    // æŒ‰ä½¿ç”¨æ•°é‡æ’åº
    const sortedPalette = Object.entries(data.palette).sort((a, b) => {
        return b[1].count - a[1].count;
    });
    
    sortedPalette.forEach(([code, info]) => {
        const item = document.createElement('div');
        item.className = 'color-item';
        item.dataset.color = info.hex;
        
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = info.hex;
        
        const info_div = document.createElement('div');
        info_div.className = 'color-info';
        
        // ç¬¬ä¸€è¡Œï¼šè‰²å·
        const codeDiv = document.createElement('div');
        codeDiv.className = 'color-code';
        codeDiv.textContent = code;
        codeDiv.style.fontWeight = 'bold';
        codeDiv.style.fontSize = '14px';
        codeDiv.style.fontFamily = '"Courier New", monospace';
        
        info_div.appendChild(codeDiv);
        
        // ç¬¬äºŒè¡Œï¼šæ•°é‡
        const count = document.createElement('div');
        count.className = 'color-count';
        count.textContent = `Ã— ${info.count}`;
        count.style.fontSize = '10px';
        count.style.fontFamily = '"Courier New", monospace';
        count.style.fontWeight = 'bold';
        
        info_div.appendChild(count);
        
        item.appendChild(swatch);
        item.appendChild(info_div);
        
        // ç‚¹å‡»é€‰æ‹©
        item.addEventListener('click', () => {
            selectColor(info.hex);
        });
        
        // æ‚¬åœæ•ˆæœ
        item.addEventListener('mouseenter', () => {
            item.style.transform = 'translateX(4px)';
        });
        
        item.addEventListener('mouseleave', () => {
            item.style.transform = 'translateX(0)';
        });
        
        container.appendChild(item);
    });
}

// ============ æ›´æ–°è‰²å·ç»Ÿè®¡é€‰ä¸­çŠ¶æ€ ============
function updateColorStatsSelection(color) {
    const items = document.querySelectorAll('.color-item');
    items.forEach(item => {
        if (item.dataset.color === color) {
            item.classList.add('active');
            item.classList.remove('dimmed');
        } else if (color) {
            item.classList.remove('active');
            item.classList.add('dimmed');
        } else {
            item.classList.remove('active');
            item.classList.remove('dimmed');
        }
    });
}

// ============ é‡ç½®ä¸Šä¼  ============
function resetUpload() {
    currentData = null;
    selectedColor = null;
    editMode = false;
    updateEditModeUI();
    cropMode = false;
    updateCropModeUI();
    
    if (originalImageUrl) {
        URL.revokeObjectURL(originalImageUrl);
        originalImageUrl = null;
    }
    
    document.getElementById('uploadSection').style.display = 'flex';
    document.getElementById('loading').style.display = 'none';
    document.getElementById('resultSection').style.display = 'none';
    document.getElementById('fileInput').value = '';
    const svgInput = document.getElementById('svgInput');
    if (svgInput) svgInput.value = '';
    
    const modal = document.getElementById('originalModal');
    if (modal) modal.style.display = 'none';
    
    const showBtn = document.getElementById('showOriginalBtn');
    if (showBtn) showBtn.style.display = 'none';
}

// ============ åº“å­˜ç®¡ç†åŠŸèƒ½ ============
let allColors = []; // å­˜å‚¨æ‰€æœ‰è‰²å·æ•°æ®

// åŠ è½½åº“å­˜é¡µé¢
async function loadInventoryPage() {
    if (allColors.length === 0) {
        // é¦–æ¬¡åŠ è½½ï¼Œä»åç«¯è·å–æ‰€æœ‰è‰²å·
        try {
            console.log('Loading all colors from API...');
            const response = await fetch('/api/all_colors');
            const data = await response.json();
            console.log('Received colors:', data);
            if (data.success && data.colors) {
                allColors = data.colors;
                console.log('Loaded', allColors.length, 'colors');
            } else {
                console.error('Invalid response:', data);
                allColors = [];
            }
        } catch (error) {
            console.error('Failed to load colors:', error);
            allColors = [];
        }
    }
    
    renderInventoryGrid();
    updateSelectedCount();
}

// æ¸²æŸ“åº“å­˜ç½‘æ ¼
function renderInventoryGrid() {
    const grid = document.getElementById('colorInventoryGrid');
    if (!grid || allColors.length === 0) return;
    
    const selectedColors = getSelectedColors();
    // å¦‚æœæ˜¯ç©ºæ•°ç»„ï¼ˆé»˜è®¤å…¨é€‰ï¼‰ï¼Œç”Ÿæˆæ‰€æœ‰è‰²å·çš„æ•°ç»„
    const isAllSelected = selectedColors.length === 0;
    
    grid.innerHTML = allColors.map(color => {
        const isSelected = isAllSelected || selectedColors.includes(color.code);
        return `
            <div class="inventory-item ${isSelected ? 'selected' : ''}" 
                 data-code="${color.code}"
                 onclick="toggleColorSelection('${color.code}')"
                 title="${color.code} - ${color.hex}">
                <div class="color-preview" style="background-color: ${color.hex}"></div>
                <div class="color-code">${color.code}</div>
            </div>
        `;
    }).join('');
}

// åˆ‡æ¢è‰²å·é€‰æ‹©
function toggleColorSelection(code) {
    let selected = getSelectedColors();
    
    // å¦‚æœå½“å‰æ˜¯ç©ºæ•°ç»„ï¼ˆå…¨é€‰çŠ¶æ€ï¼‰ï¼Œå…ˆå¡«å……æ‰€æœ‰è‰²å·
    if (selected.length === 0) {
        selected = allColors.map(c => c.code);
    }
    
    const index = selected.indexOf(code);
    
    if (index > -1) {
        selected.splice(index, 1);
    } else {
        selected.push(code);
    }
    
    saveSelectedColors(selected);
    renderInventoryGrid();
    updateSelectedCount();
}

// å…¨é€‰
function selectAllColors() {
    const allCodes = allColors.map(c => c.code);
    saveSelectedColors(allCodes);
    renderInventoryGrid();
    updateSelectedCount();
}

// å–æ¶ˆå…¨é€‰
function deselectAllColors() {
    saveSelectedColors([]);
    renderInventoryGrid();
    updateSelectedCount();
}

// è·å–å·²é€‰æ‹©çš„è‰²å·ï¼ˆä»localStorageï¼‰
function getSelectedColors() {
    const saved = localStorage.getItem('selectedColors');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            // å¦‚æœè§£ææˆåŠŸä¸”æ˜¯æ•°ç»„ï¼Œè¿”å›
            if (Array.isArray(parsed)) {
                return parsed;
            }
        } catch (e) {
            console.error('Failed to parse selectedColors:', e);
        }
    }
    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„æ•°æ®ï¼Œè¿”å›ç©ºæ•°ç»„ï¼ˆè¡¨ç¤ºå…¨é€‰ï¼‰
    // æ³¨æ„ï¼šç©ºæ•°ç»„åœ¨åç«¯ä¼šè¢«è§£é‡Šä¸º"ä½¿ç”¨æ‰€æœ‰è‰²å·"
    return [];
}

// ä¿å­˜å·²é€‰æ‹©çš„è‰²å·
function saveSelectedColors(codes) {
    localStorage.setItem('selectedColors', JSON.stringify(codes));
}

// æ›´æ–°é€‰ä¸­æ•°é‡æ˜¾ç¤º
function updateSelectedCount() {
    const countEl = document.getElementById('selectedCount');
    if (countEl && allColors.length > 0) {
        const selected = getSelectedColors();
        // å¦‚æœæ˜¯ç©ºæ•°ç»„ï¼Œæ˜¾ç¤ºå…¨é€‰
        const displayCount = selected.length === 0 ? allColors.length : selected.length;
        countEl.textContent = `${displayCount} / ${allColors.length} colors selected`;
    }
}
